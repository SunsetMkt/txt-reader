/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./factory/txt-reader-for-node.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./factory/txt-reader-for-node.js":
/*!****************************************!*\
  !*** ./factory/txt-reader-for-node.js ***!
  \****************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _txt_reader_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../txt-reader.ts */ \"./txt-reader.ts\");\n/* harmony import */ var _txt_reader_ts__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_txt_reader_ts__WEBPACK_IMPORTED_MODULE_0__);\n\r\nexports.TxtReader = _txt_reader_ts__WEBPACK_IMPORTED_MODULE_0__[\"TxtReader\"]; \n\n//# sourceURL=webpack:///./factory/txt-reader-for-node.js?");

/***/ }),

/***/ "./node_modules/lodash.clonedeep/index.js":
/*!************************************************!*\
  !*** ./node_modules/lodash.clonedeep/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, module) {/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/**\n * Adds the key-value `pair` to `map`.\n *\n * @private\n * @param {Object} map The map to modify.\n * @param {Array} pair The key-value pair to add.\n * @returns {Object} Returns `map`.\n */\nfunction addMapEntry(map, pair) {\n  // Don't return `map.set` because it's not chainable in IE 11.\n  map.set(pair[0], pair[1]);\n  return map;\n}\n\n/**\n * Adds `value` to `set`.\n *\n * @private\n * @param {Object} set The set to modify.\n * @param {*} value The value to add.\n * @returns {Object} Returns `set`.\n */\nfunction addSetEntry(set, value) {\n  // Don't return `set.add` because it's not chainable in IE 11.\n  set.add(value);\n  return set;\n}\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    getPrototype = overArg(Object.getPrototypeOf, Object),\n    objectCreate = Object.create,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  this.__data__ = new ListCache(entries);\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  return this.__data__['delete'](key);\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var cache = this.__data__;\n  if (cache instanceof ListCache) {\n    var pairs = cache.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      return this;\n    }\n    cache = this.__data__ = new MapCache(pairs);\n  }\n  cache.set(key, value);\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = (isArray(value) || isArguments(value))\n    ? baseTimes(value.length, String)\n    : [];\n\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    object[key] = value;\n  }\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @param {boolean} [isFull] Specify a clone including symbols.\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, isDeep, isFull, customizer, key, object, stack) {\n  var result;\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      if (isHostObject(value)) {\n        return object ? value : {};\n      }\n      result = initCloneObject(isFunc ? {} : value);\n      if (!isDeep) {\n        return copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, baseClone, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (!isArr) {\n    var props = isFull ? getAllKeys(value) : keys(value);\n  }\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));\n  });\n  return result;\n}\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} prototype The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nfunction baseCreate(proto) {\n  return isObject(proto) ? objectCreate(proto) : {};\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  return objectToString.call(value);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var result = new buffer.constructor(buffer.length);\n  buffer.copy(result);\n  return result;\n}\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\n/**\n * Creates a clone of `map`.\n *\n * @private\n * @param {Object} map The map to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned map.\n */\nfunction cloneMap(map, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);\n  return arrayReduce(array, addMapEntry, new map.constructor);\n}\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\n/**\n * Creates a clone of `set`.\n *\n * @private\n * @param {Object} set The set to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned set.\n */\nfunction cloneSet(set, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);\n  return arrayReduce(array, addSetEntry, new set.constructor);\n}\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    assignValue(object, key, newValue === undefined ? source[key] : newValue);\n  }\n  return object;\n}\n\n/**\n * Copies own symbol properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Creates an array of the own enumerable symbol properties of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11,\n// for data views in Edge < 14, and promises in Node.js.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = objectToString.call(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : undefined;\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, cloneFunc, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return cloneMap(object, isDeep, cloneFunc);\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return cloneSet(object, isDeep, cloneFunc);\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, true, true);\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = cloneDeep;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./node_modules/lodash.clonedeep/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/promise-polyfill/src/finally.js":
/*!******************************************************!*\
  !*** ./node_modules/promise-polyfill/src/finally.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * @this {Promise}\n */\nfunction finallyConstructor(callback) {\n  var constructor = this.constructor;\n  return this.then(\n    function(value) {\n      // @ts-ignore\n      return constructor.resolve(callback()).then(function() {\n        return value;\n      });\n    },\n    function(reason) {\n      // @ts-ignore\n      return constructor.resolve(callback()).then(function() {\n        // @ts-ignore\n        return constructor.reject(reason);\n      });\n    }\n  );\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (finallyConstructor);\n\n\n//# sourceURL=webpack:///./node_modules/promise-polyfill/src/finally.js?");

/***/ }),

/***/ "./node_modules/promise-polyfill/src/index.js":
/*!****************************************************!*\
  !*** ./node_modules/promise-polyfill/src/index.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(setImmediate) {/* harmony import */ var _finally__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./finally */ \"./node_modules/promise-polyfill/src/finally.js\");\n\n\n// Store setTimeout reference so promise-polyfill will be unaffected by\n// other code modifying setTimeout (like sinon.useFakeTimers())\nvar setTimeoutFunc = setTimeout;\n\nfunction isArray(x) {\n  return Boolean(x && typeof x.length !== 'undefined');\n}\n\nfunction noop() {}\n\n// Polyfill for Function.prototype.bind\nfunction bind(fn, thisArg) {\n  return function() {\n    fn.apply(thisArg, arguments);\n  };\n}\n\n/**\n * @constructor\n * @param {Function} fn\n */\nfunction Promise(fn) {\n  if (!(this instanceof Promise))\n    throw new TypeError('Promises must be constructed via new');\n  if (typeof fn !== 'function') throw new TypeError('not a function');\n  /** @type {!number} */\n  this._state = 0;\n  /** @type {!boolean} */\n  this._handled = false;\n  /** @type {Promise|undefined} */\n  this._value = undefined;\n  /** @type {!Array<!Function>} */\n  this._deferreds = [];\n\n  doResolve(fn, this);\n}\n\nfunction handle(self, deferred) {\n  while (self._state === 3) {\n    self = self._value;\n  }\n  if (self._state === 0) {\n    self._deferreds.push(deferred);\n    return;\n  }\n  self._handled = true;\n  Promise._immediateFn(function() {\n    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n      return;\n    }\n    var ret;\n    try {\n      ret = cb(self._value);\n    } catch (e) {\n      reject(deferred.promise, e);\n      return;\n    }\n    resolve(deferred.promise, ret);\n  });\n}\n\nfunction resolve(self, newValue) {\n  try {\n    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n    if (newValue === self)\n      throw new TypeError('A promise cannot be resolved with itself.');\n    if (\n      newValue &&\n      (typeof newValue === 'object' || typeof newValue === 'function')\n    ) {\n      var then = newValue.then;\n      if (newValue instanceof Promise) {\n        self._state = 3;\n        self._value = newValue;\n        finale(self);\n        return;\n      } else if (typeof then === 'function') {\n        doResolve(bind(then, newValue), self);\n        return;\n      }\n    }\n    self._state = 1;\n    self._value = newValue;\n    finale(self);\n  } catch (e) {\n    reject(self, e);\n  }\n}\n\nfunction reject(self, newValue) {\n  self._state = 2;\n  self._value = newValue;\n  finale(self);\n}\n\nfunction finale(self) {\n  if (self._state === 2 && self._deferreds.length === 0) {\n    Promise._immediateFn(function() {\n      if (!self._handled) {\n        Promise._unhandledRejectionFn(self._value);\n      }\n    });\n  }\n\n  for (var i = 0, len = self._deferreds.length; i < len; i++) {\n    handle(self, self._deferreds[i]);\n  }\n  self._deferreds = null;\n}\n\n/**\n * @constructor\n */\nfunction Handler(onFulfilled, onRejected, promise) {\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, self) {\n  var done = false;\n  try {\n    fn(\n      function(value) {\n        if (done) return;\n        done = true;\n        resolve(self, value);\n      },\n      function(reason) {\n        if (done) return;\n        done = true;\n        reject(self, reason);\n      }\n    );\n  } catch (ex) {\n    if (done) return;\n    done = true;\n    reject(self, ex);\n  }\n}\n\nPromise.prototype['catch'] = function(onRejected) {\n  return this.then(null, onRejected);\n};\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  // @ts-ignore\n  var prom = new this.constructor(noop);\n\n  handle(this, new Handler(onFulfilled, onRejected, prom));\n  return prom;\n};\n\nPromise.prototype['finally'] = _finally__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n\nPromise.all = function(arr) {\n  return new Promise(function(resolve, reject) {\n    if (!isArray(arr)) {\n      return reject(new TypeError('Promise.all accepts an array'));\n    }\n\n    var args = Array.prototype.slice.call(arr);\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n\n    function res(i, val) {\n      try {\n        if (val && (typeof val === 'object' || typeof val === 'function')) {\n          var then = val.then;\n          if (typeof then === 'function') {\n            then.call(\n              val,\n              function(val) {\n                res(i, val);\n              },\n              reject\n            );\n            return;\n          }\n        }\n        args[i] = val;\n        if (--remaining === 0) {\n          resolve(args);\n        }\n      } catch (ex) {\n        reject(ex);\n      }\n    }\n\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.resolve = function(value) {\n  if (value && typeof value === 'object' && value.constructor === Promise) {\n    return value;\n  }\n\n  return new Promise(function(resolve) {\n    resolve(value);\n  });\n};\n\nPromise.reject = function(value) {\n  return new Promise(function(resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function(arr) {\n  return new Promise(function(resolve, reject) {\n    if (!isArray(arr)) {\n      return reject(new TypeError('Promise.race accepts an array'));\n    }\n\n    for (var i = 0, len = arr.length; i < len; i++) {\n      Promise.resolve(arr[i]).then(resolve, reject);\n    }\n  });\n};\n\n// Use polyfill for setImmediate for performance gains\nPromise._immediateFn =\n  // @ts-ignore\n  (typeof setImmediate === 'function' &&\n    function(fn) {\n      // @ts-ignore\n      setImmediate(fn);\n    }) ||\n  function(fn) {\n    setTimeoutFunc(fn, 0);\n  };\n\nPromise._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n  if (typeof console !== 'undefined' && console) {\n    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n  }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Promise);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))\n\n//# sourceURL=webpack:///./node_modules/promise-polyfill/src/index.js?");

/***/ }),

/***/ "./node_modules/promise-polyfill/src/polyfill.js":
/*!*******************************************************!*\
  !*** ./node_modules/promise-polyfill/src/polyfill.js ***!
  \*******************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ \"./node_modules/promise-polyfill/src/index.js\");\n/* harmony import */ var _finally__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./finally */ \"./node_modules/promise-polyfill/src/finally.js\");\n\n\n\n/** @suppress {undefinedVars} */\nvar globalNS = (function() {\n  // the only reliable means to get the global object is\n  // `Function('return this')()`\n  // However, this causes CSP violations in Chrome apps.\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  throw new Error('unable to locate global object');\n})();\n\nif (!('Promise' in globalNS)) {\n  globalNS['Promise'] = _index__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n} else if (!globalNS.Promise.prototype['finally']) {\n  globalNS.Promise.prototype['finally'] = _finally__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/promise-polyfill/src/polyfill.js?");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/setimmediate/setImmediate.js?");

/***/ }),

/***/ "./node_modules/text-encoding-shim/index.js":
/*!**************************************************!*\
  !*** ./node_modules/text-encoding-shim/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else { var textEncoding; }\n}(this, function () {\n\t\"use strict\";\n\t// return native implementation if available\n\tvar g = typeof global !== 'undefined' ? global : self;\n\tif (typeof g.TextEncoder !== 'undefined' && typeof g.TextDecoder !== 'undefined') {\n\t\treturn {'TextEncoder': g.TextEncoder, 'TextDecoder': g.TextDecoder};\n\t}\n\n\t// allowed encoding strings for utf-8\n\tvar utf8Encodings = [\n\t\t'utf8',\n\t\t'utf-8',\n\t\t'unicode-1-1-utf-8'\n\t];\n\n\tvar TextEncoder = function(encoding) {\n\t\tif (utf8Encodings.indexOf(encoding) < 0 && typeof encoding !== 'undefined' && encoding !== null) {\n\t\t\tthrow new RangeError('Invalid encoding type. Only utf-8 is supported');\n\t\t} else {\n\t\t\tthis.encoding = 'utf-8';\n\t\t\tthis.encode = function(str) {\n\t\t\t\tif (typeof str !== 'string') {\n\t\t\t\t\tthrow new TypeError('passed argument must be of type string');\n\t\t\t\t}\n\t\t\t\tvar binstr = unescape(encodeURIComponent(str)),\n\t\t\t\t\tarr = new Uint8Array(binstr.length);\n\t\t\t\tbinstr.split('').forEach(function(char, i) {\n\t\t\t\t\tarr[i] = char.charCodeAt(0);\n\t\t\t\t});\n\t\t\t\treturn arr;\n\t\t\t};\n\t\t}\n\t};\n\n\tvar TextDecoder = function(encoding, options) {\n\t\tif (utf8Encodings.indexOf(encoding) < 0 && typeof encoding !== 'undefined' && encoding !== null) {\n\t\t\tthrow new RangeError('Invalid encoding type. Only utf-8 is supported');\n\t\t}\n\t\tthis.encoding = 'utf-8';\n\t\tthis.ignoreBOM = false;\n\t\tthis.fatal = (typeof options !== 'undefined' && 'fatal' in options) ? options.fatal : false;\n\t\tif (typeof this.fatal !== 'boolean') {\n\t\t\tthrow new TypeError('fatal flag must be boolean');\n\t\t}\n\t\tthis.decode = function (view, options) {\n\t\t\tif (typeof view === 'undefined') {\n\t\t\t\treturn '';\n\t\t\t}\n\n\t\t\tvar stream = (typeof options !== 'undefined' && 'stream' in options) ? options.stream : false;\n\t\t\tif (typeof stream !== 'boolean') {\n\t\t\t\tthrow new TypeError('stream option must be boolean');\n\t\t\t}\n\n\t\t\tif (!ArrayBuffer.isView(view)) {\n\t\t\t\tthrow new TypeError('passed argument must be an array buffer view');\n\t\t\t} else {\n\t\t\t\tvar arr = new Uint8Array(view.buffer),\n\t\t\t\t\tcharArr = new Array(arr.length);\n\t\t\t\tarr.forEach(function(charcode, i) {\n\t\t\t\t\tcharArr[i] = String.fromCharCode(charcode);\n\t\t\t\t});\n\t\t\t\treturn decodeURIComponent(escape(charArr.join('')));\n\t\t\t}\n\t\t};\n\t};\n\treturn {'TextEncoder': TextEncoder, 'TextDecoder': TextDecoder};\n}));\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/text-encoding-shim/index.js?");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/timers-browserify/main.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/module.js?");

/***/ }),

/***/ "./polyfill.ts":
/*!*********************!*\
  !*** ./polyfill.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nif (Uint8Array.prototype.indexOf === undefined) {\r\n    Uint8Array.prototype.indexOf = function (value) {\r\n        return Array.prototype.indexOf.call(this, value);\r\n    };\r\n}\r\nif (Uint8Array.prototype.slice === undefined) {\r\n    Uint8Array.prototype.slice = function (begin, end) {\r\n        return new Uint8Array(Array.prototype.slice.call(this, begin, end));\r\n    };\r\n}\r\nif (!Uint8Array.prototype.forEach) {\r\n    Uint8Array.prototype.forEach = function (callback /*, thisArg*/) {\r\n        var T, k;\r\n        if (this == null) {\r\n            throw new TypeError('this is null or not defined');\r\n        }\r\n        // 1. Let O be the result of calling toObject() passing the\r\n        // |this| value as the argument.\r\n        var O = Object(this);\r\n        // 2. Let lenValue be the result of calling the Get() internal\r\n        // method of O with the argument \"length\".\r\n        // 3. Let len be toUint32(lenValue).\r\n        var len = O.length >>> 0;\r\n        // 4. If isCallable(callback) is false, throw a TypeError exception. \r\n        // See: http://es5.github.com/#x9.11\r\n        if (typeof callback !== 'function') {\r\n            throw new TypeError(callback + ' is not a function');\r\n        }\r\n        // 5. If thisArg was supplied, let T be thisArg; else let\r\n        // T be undefined.\r\n        if (arguments.length > 1) {\r\n            T = arguments[1];\r\n        }\r\n        // 6. Let k be 0.\r\n        k = 0;\r\n        // 7. Repeat while k < len.\r\n        while (k < len) {\r\n            var kValue;\r\n            // a. Let Pk be ToString(k).\r\n            //    This is implicit for LHS operands of the in operator.\r\n            // b. Let kPresent be the result of calling the HasProperty\r\n            //    internal method of O with argument Pk.\r\n            //    This step can be combined with c.\r\n            // c. If kPresent is true, then\r\n            if (k in O) {\r\n                // i. Let kValue be the result of calling the Get internal\r\n                // method of O with argument Pk.\r\n                kValue = O[k];\r\n                // ii. Call the Call internal method of callback with T as\r\n                // the this value and argument list containing kValue, k, and O.\r\n                callback.call(T, kValue, k, O);\r\n            }\r\n            // d. Increase k by 1.\r\n            k++;\r\n        }\r\n        // 8. return undefined.\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack:///./polyfill.ts?");

/***/ }),

/***/ "./txt-reader.ts":
/*!***********************!*\
  !*** ./txt-reader.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nexports.__esModule = true;\r\nvar text_encoding_shim_1 = __webpack_require__(/*! text-encoding-shim */ \"./node_modules/text-encoding-shim/index.js\");\r\n__webpack_require__(/*! promise-polyfill/src/polyfill */ \"./node_modules/promise-polyfill/src/polyfill.js\");\r\n__webpack_require__(/*! ./polyfill */ \"./polyfill.ts\");\r\nvar lodash_clonedeep_1 = __importDefault(__webpack_require__(/*! lodash.clonedeep */ \"./node_modules/lodash.clonedeep/index.js\"));\r\nvar RequestMessage = /** @class */ (function () {\r\n    function RequestMessage(action, data) {\r\n        this.action = action;\r\n        this.data = data !== undefined ? data : null;\r\n    }\r\n    return RequestMessage;\r\n}());\r\nvar TxtReaderTaskState;\r\n(function (TxtReaderTaskState) {\r\n    TxtReaderTaskState[TxtReaderTaskState[\"Initialized\"] = 0] = \"Initialized\";\r\n    TxtReaderTaskState[TxtReaderTaskState[\"Queued\"] = 1] = \"Queued\";\r\n    TxtReaderTaskState[TxtReaderTaskState[\"Running\"] = 2] = \"Running\";\r\n    TxtReaderTaskState[TxtReaderTaskState[\"Completed\"] = 3] = \"Completed\";\r\n})(TxtReaderTaskState || (TxtReaderTaskState = {}));\r\nvar TxtReaderTask = /** @class */ (function () {\r\n    function TxtReaderTask(id, reqMsg, parser) {\r\n        var _this = this;\r\n        this.id = id;\r\n        this.requestMessage = reqMsg;\r\n        this.parser = parser;\r\n        this.requestMessage.taskId = id;\r\n        this.state = TxtReaderTaskState.Initialized;\r\n        this.onProgress = null;\r\n        this.startTime = 0;\r\n        // initialize the task promise object, assign the resolve, reject methods.\r\n        this.promise = new Promise(function (resolve, reject) {\r\n            _this.resolve = resolve;\r\n            _this.reject = reject;\r\n        });\r\n    }\r\n    TxtReaderTask.prototype.dispose = function () {\r\n        // release the memory inside promise obejct\r\n        this.resolve = null;\r\n        this.reject = null;\r\n        this.promise = null;\r\n    };\r\n    // run the task, postMessage would be triggered in TxtReader\r\n    // just change the state and record the task start time here\r\n    TxtReaderTask.prototype.run = function () {\r\n        this.state = TxtReaderTaskState.Running;\r\n        this.startTime = new Date().getTime();\r\n    };\r\n    // be called when a task completes no matter it succeeds or fails\r\n    TxtReaderTask.prototype.complete = function (response) {\r\n        this.state = TxtReaderTaskState.Completed;\r\n        var timeTaken = new Date().getTime() - this.startTime;\r\n        if (response.success) {\r\n            var taskResponse = {\r\n                timeTaken: timeTaken,\r\n                message: response.message,\r\n                result: response.result\r\n            };\r\n            this.resolve(taskResponse);\r\n        }\r\n        else {\r\n            this.reject(response.message);\r\n        }\r\n        this.dispose();\r\n    };\r\n    TxtReaderTask.prototype.updateProgress = function (progress) {\r\n        if (this.onProgress !== null) {\r\n            this.onProgress.call(this.parser, progress);\r\n        }\r\n    };\r\n    TxtReaderTask.prototype.then = function (onFulFilled) {\r\n        var _this = this;\r\n        if (this.promise) {\r\n            this.promise.then(function (data) {\r\n                onFulFilled.call(_this.parser, data);\r\n            })[\"catch\"](function (reason) { });\r\n        }\r\n        return this;\r\n    };\r\n    TxtReaderTask.prototype[\"catch\"] = function (onFailed) {\r\n        var _this = this;\r\n        if (this.promise) {\r\n            this.promise[\"catch\"](function (reason) {\r\n                onFailed.call(_this.parser, reason);\r\n            });\r\n        }\r\n        return this;\r\n    };\r\n    TxtReaderTask.prototype.progress = function (onProgress) {\r\n        this.onProgress = onProgress;\r\n        return this;\r\n    };\r\n    return TxtReaderTask;\r\n}());\r\nvar TxtReader = /** @class */ (function () {\r\n    function TxtReader() {\r\n        var _this = this;\r\n        this.taskList = [];\r\n        this.runningTask = null;\r\n        this.queuedTaskList = [];\r\n        this.verboseLogging = false;\r\n        this.utf8decoder = new text_encoding_shim_1.TextDecoder(\'utf-8\');\r\n        this.lineCount = 0;\r\n        Object.defineProperty(this, \'lineCount\', {\r\n            value: 0,\r\n            writable: false\r\n        });\r\n        this.file = null;\r\n        this.worker = new Worker(window.URL.createObjectURL(new Blob([\"/******/ (function(modules) { // webpackBootstrap\\n/******/ \\t// The module cache\\n/******/ \\tvar installedModules = {};\\n/******/\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tif(installedModules[moduleId]) {\\n/******/ \\t\\t\\treturn installedModules[moduleId].exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = installedModules[moduleId] = {\\n/******/ \\t\\t\\ti: moduleId,\\n/******/ \\t\\t\\tl: false,\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.l = true;\\n/******/\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/\\n/******/\\n/******/ \\t// expose the modules object (__webpack_modules__)\\n/******/ \\t__webpack_require__.m = modules;\\n/******/\\n/******/ \\t// expose the module cache\\n/******/ \\t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \\t// define getter function for harmony exports\\n/******/ \\t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \\t\\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n/******/ \\t\\t}\\n/******/ \\t};\\n/******/\\n/******/ \\t// define __esModule on exports\\n/******/ \\t__webpack_require__.r = function(exports) {\\n/******/ \\t\\tif(typeof Symbol !== \\\'undefined\\\' && Symbol.toStringTag) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: \\\'Module\\\' });\\n/******/ \\t\\t}\\n/******/ \\t\\tObject.defineProperty(exports, \\\'__esModule\\\', { value: true });\\n/******/ \\t};\\n/******/\\n/******/ \\t// create a fake namespace object\\n/******/ \\t// mode & 1: value is a module id, require it\\n/******/ \\t// mode & 2: merge all properties of value into the ns\\n/******/ \\t// mode & 4: return value when already ns object\\n/******/ \\t// mode & 8|1: behave like require\\n/******/ \\t__webpack_require__.t = function(value, mode) {\\n/******/ \\t\\tif(mode & 1) value = __webpack_require__(value);\\n/******/ \\t\\tif(mode & 8) return value;\\n/******/ \\t\\tif((mode & 4) && typeof value === \\\'object\\\' && value && value.__esModule) return value;\\n/******/ \\t\\tvar ns = Object.create(null);\\n/******/ \\t\\t__webpack_require__.r(ns);\\n/******/ \\t\\tObject.defineProperty(ns, \\\'default\\\', { enumerable: true, value: value });\\n/******/ \\t\\tif(mode & 2 && typeof value != \\\'string\\\') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n/******/ \\t\\treturn ns;\\n/******/ \\t};\\n/******/\\n/******/ \\t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \\t__webpack_require__.n = function(module) {\\n/******/ \\t\\tvar getter = module && module.__esModule ?\\n/******/ \\t\\t\\tfunction getDefault() { return module[\\\'default\\\']; } :\\n/******/ \\t\\t\\tfunction getModuleExports() { return module; };\\n/******/ \\t\\t__webpack_require__.d(getter, \\\'a\\\', getter);\\n/******/ \\t\\treturn getter;\\n/******/ \\t};\\n/******/\\n/******/ \\t// Object.prototype.hasOwnProperty.call\\n/******/ \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \\t// __webpack_public_path__\\n/******/ \\t__webpack_require__.p = \\\"\\\";\\n/******/\\n/******/\\n/******/ \\t// Load entry module and return exports\\n/******/ \\treturn __webpack_require__(__webpack_require__.s = \\\"./txt-reader-worker.ts\\\");\\n/******/ })\\n/************************************************************************/\\n/******/ ({\\n\\n/***/ \\\"./node_modules/text-encoding-shim/index.js\\\":\\n/*!**************************************************!*\\\\\\n  !*** ./node_modules/text-encoding-shim/index.js ***!\\n  \\\\**************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\neval(\\\"/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\\\\n    if (true) {\\\\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\\\\n\\\\t\\\\t\\\\t\\\\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \\\'function\\\' ?\\\\n\\\\t\\\\t\\\\t\\\\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\\\\n\\\\t\\\\t\\\\t\\\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\\\\n    } else { var textEncoding; }\\\\n}(this, function () {\\\\n\\\\t\\\\\\\"use strict\\\\\\\";\\\\n\\\\t// return native implementation if available\\\\n\\\\tvar g = typeof global !== \\\'undefined\\\' ? global : self;\\\\n\\\\tif (typeof g.TextEncoder !== \\\'undefined\\\' && typeof g.TextDecoder !== \\\'undefined\\\') {\\\\n\\\\t\\\\treturn {\\\'TextEncoder\\\': g.TextEncoder, \\\'TextDecoder\\\': g.TextDecoder};\\\\n\\\\t}\\\\n\\\\n\\\\t// allowed encoding strings for utf-8\\\\n\\\\tvar utf8Encodings = [\\\\n\\\\t\\\\t\\\'utf8\\\',\\\\n\\\\t\\\\t\\\'utf-8\\\',\\\\n\\\\t\\\\t\\\'unicode-1-1-utf-8\\\'\\\\n\\\\t];\\\\n\\\\n\\\\tvar TextEncoder = function(encoding) {\\\\n\\\\t\\\\tif (utf8Encodings.indexOf(encoding) < 0 && typeof encoding !== \\\'undefined\\\' && encoding !== null) {\\\\n\\\\t\\\\t\\\\tthrow new RangeError(\\\'Invalid encoding type. Only utf-8 is supported\\\');\\\\n\\\\t\\\\t} else {\\\\n\\\\t\\\\t\\\\tthis.encoding = \\\'utf-8\\\';\\\\n\\\\t\\\\t\\\\tthis.encode = function(str) {\\\\n\\\\t\\\\t\\\\t\\\\tif (typeof str !== \\\'string\\\') {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tthrow new TypeError(\\\'passed argument must be of type string\\\');\\\\n\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\tvar binstr = unescape(encodeURIComponent(str)),\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tarr = new Uint8Array(binstr.length);\\\\n\\\\t\\\\t\\\\t\\\\tbinstr.split(\\\'\\\').forEach(function(char, i) {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tarr[i] = char.charCodeAt(0);\\\\n\\\\t\\\\t\\\\t\\\\t});\\\\n\\\\t\\\\t\\\\t\\\\treturn arr;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t}\\\\n\\\\t};\\\\n\\\\n\\\\tvar TextDecoder = function(encoding, options) {\\\\n\\\\t\\\\tif (utf8Encodings.indexOf(encoding) < 0 && typeof encoding !== \\\'undefined\\\' && encoding !== null) {\\\\n\\\\t\\\\t\\\\tthrow new RangeError(\\\'Invalid encoding type. Only utf-8 is supported\\\');\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\tthis.encoding = \\\'utf-8\\\';\\\\n\\\\t\\\\tthis.ignoreBOM = false;\\\\n\\\\t\\\\tthis.fatal = (typeof options !== \\\'undefined\\\' && \\\'fatal\\\' in options) ? options.fatal : false;\\\\n\\\\t\\\\tif (typeof this.fatal !== \\\'boolean\\\') {\\\\n\\\\t\\\\t\\\\tthrow new TypeError(\\\'fatal flag must be boolean\\\');\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\tthis.decode = function (view, options) {\\\\n\\\\t\\\\t\\\\tif (typeof view === \\\'undefined\\\') {\\\\n\\\\t\\\\t\\\\t\\\\treturn \\\'\\\';\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tvar stream = (typeof options !== \\\'undefined\\\' && \\\'stream\\\' in options) ? options.stream : false;\\\\n\\\\t\\\\t\\\\tif (typeof stream !== \\\'boolean\\\') {\\\\n\\\\t\\\\t\\\\t\\\\tthrow new TypeError(\\\'stream option must be boolean\\\');\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tif (!ArrayBuffer.isView(view)) {\\\\n\\\\t\\\\t\\\\t\\\\tthrow new TypeError(\\\'passed argument must be an array buffer view\\\');\\\\n\\\\t\\\\t\\\\t} else {\\\\n\\\\t\\\\t\\\\t\\\\tvar arr = new Uint8Array(view.buffer),\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tcharArr = new Array(arr.length);\\\\n\\\\t\\\\t\\\\t\\\\tarr.forEach(function(charcode, i) {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tcharArr[i] = String.fromCharCode(charcode);\\\\n\\\\t\\\\t\\\\t\\\\t});\\\\n\\\\t\\\\t\\\\t\\\\treturn decodeURIComponent(escape(charArr.join(\\\'\\\')));\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t};\\\\n\\\\t};\\\\n\\\\treturn {\\\'TextEncoder\\\': TextEncoder, \\\'TextDecoder\\\': TextDecoder};\\\\n}));\\\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \\\\\\\"./node_modules/webpack/buildin/global.js\\\\\\\")))\\\\n\\\\n//# sourceURL=webpack:///./node_modules/text-encoding-shim/index.js?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/webpack/buildin/global.js\\\":\\n/*!***********************************!*\\\\\\n  !*** (webpack)/buildin/global.js ***!\\n  \\\\***********************************/\\n/*! no static exports found */\\n/***/ (function(module, exports) {\\n\\neval(\\\"var g;\\\\n\\\\n// This works in non-strict mode\\\\ng = (function() {\\\\n\\\\treturn this;\\\\n})();\\\\n\\\\ntry {\\\\n\\\\t// This works if eval is allowed (see CSP)\\\\n\\\\tg = g || new Function(\\\\\\\"return this\\\\\\\")();\\\\n} catch (e) {\\\\n\\\\t// This works if the window reference is available\\\\n\\\\tif (typeof window === \\\\\\\"object\\\\\\\") g = window;\\\\n}\\\\n\\\\n// g can still be undefined, but nothing to do about it...\\\\n// We return undefined, instead of nothing here, so it\\\'s\\\\n// easier to handle this case. if(!global) { ...}\\\\n\\\\nmodule.exports = g;\\\\n\\\\n\\\\n//# sourceURL=webpack:///(webpack)/buildin/global.js?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./polyfill.ts\\\":\\n/*!*********************!*\\\\\\n  !*** ./polyfill.ts ***!\\n  \\\\*********************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"\\\\r\\\\nif (Uint8Array.prototype.indexOf === undefined) {\\\\r\\\\n    Uint8Array.prototype.indexOf = function (value) {\\\\r\\\\n        return Array.prototype.indexOf.call(this, value);\\\\r\\\\n    };\\\\r\\\\n}\\\\r\\\\nif (Uint8Array.prototype.slice === undefined) {\\\\r\\\\n    Uint8Array.prototype.slice = function (begin, end) {\\\\r\\\\n        return new Uint8Array(Array.prototype.slice.call(this, begin, end));\\\\r\\\\n    };\\\\r\\\\n}\\\\r\\\\nif (!Uint8Array.prototype.forEach) {\\\\r\\\\n    Uint8Array.prototype.forEach = function (callback /*, thisArg*/) {\\\\r\\\\n        var T, k;\\\\r\\\\n        if (this == null) {\\\\r\\\\n            throw new TypeError(\\\'this is null or not defined\\\');\\\\r\\\\n        }\\\\r\\\\n        // 1. Let O be the result of calling toObject() passing the\\\\r\\\\n        // |this| value as the argument.\\\\r\\\\n        var O = Object(this);\\\\r\\\\n        // 2. Let lenValue be the result of calling the Get() internal\\\\r\\\\n        // method of O with the argument \\\\\\\"length\\\\\\\".\\\\r\\\\n        // 3. Let len be toUint32(lenValue).\\\\r\\\\n        var len = O.length >>> 0;\\\\r\\\\n        // 4. If isCallable(callback) is false, throw a TypeError exception. \\\\r\\\\n        // See: http://es5.github.com/#x9.11\\\\r\\\\n        if (typeof callback !== \\\'function\\\') {\\\\r\\\\n            throw new TypeError(callback + \\\' is not a function\\\');\\\\r\\\\n        }\\\\r\\\\n        // 5. If thisArg was supplied, let T be thisArg; else let\\\\r\\\\n        // T be undefined.\\\\r\\\\n        if (arguments.length > 1) {\\\\r\\\\n            T = arguments[1];\\\\r\\\\n        }\\\\r\\\\n        // 6. Let k be 0.\\\\r\\\\n        k = 0;\\\\r\\\\n        // 7. Repeat while k < len.\\\\r\\\\n        while (k < len) {\\\\r\\\\n            var kValue;\\\\r\\\\n            // a. Let Pk be ToString(k).\\\\r\\\\n            //    This is implicit for LHS operands of the in operator.\\\\r\\\\n            // b. Let kPresent be the result of calling the HasProperty\\\\r\\\\n            //    internal method of O with argument Pk.\\\\r\\\\n            //    This step can be combined with c.\\\\r\\\\n            // c. If kPresent is true, then\\\\r\\\\n            if (k in O) {\\\\r\\\\n                // i. Let kValue be the result of calling the Get internal\\\\r\\\\n                // method of O with argument Pk.\\\\r\\\\n                kValue = O[k];\\\\r\\\\n                // ii. Call the Call internal method of callback with T as\\\\r\\\\n                // the this value and argument list containing kValue, k, and O.\\\\r\\\\n                callback.call(T, kValue, k, O);\\\\r\\\\n            }\\\\r\\\\n            // d. Increase k by 1.\\\\r\\\\n            k++;\\\\r\\\\n        }\\\\r\\\\n        // 8. return undefined.\\\\r\\\\n    };\\\\r\\\\n}\\\\r\\\\n\\\\n\\\\n//# sourceURL=webpack:///./polyfill.ts?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./txt-reader-worker.ts\\\":\\n/*!******************************!*\\\\\\n  !*** ./txt-reader-worker.ts ***!\\n  \\\\******************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"\\\\r\\\\nexports.__esModule = true;\\\\r\\\\nvar text_encoding_shim_1 = __webpack_require__(/*! text-encoding-shim */ \\\\\\\"./node_modules/text-encoding-shim/index.js\\\\\\\");\\\\r\\\\n__webpack_require__(/*! ./polyfill */ \\\\\\\"./polyfill.ts\\\\\\\");\\\\r\\\\nvar utf8decoder = new text_encoding_shim_1.TextDecoder(\\\'utf-8\\\');\\\\r\\\\nvar DEFAULT_CHUNK_SIZE = 1024 * 1024 * 50;\\\\r\\\\nvar currentTaskId = null;\\\\r\\\\nvar txtReaderWorker = null;\\\\r\\\\nvar sniffWorker = null;\\\\r\\\\nvar verboseLogging = false;\\\\r\\\\nvar useTransferrable = navigator.userAgent.indexOf(\\\'Firefox\\\') > -1;\\\\r\\\\nvar respondMessage = function (responseMessage) {\\\\r\\\\n    if (responseMessage.done) {\\\\r\\\\n        currentTaskId = null;\\\\r\\\\n    }\\\\r\\\\n    postMessage.apply(null, [responseMessage]);\\\\r\\\\n};\\\\r\\\\nvar respondTransferrableMessage = function (responseMessage, arr) {\\\\r\\\\n    if (responseMessage.done) {\\\\r\\\\n        currentTaskId = null;\\\\r\\\\n    }\\\\r\\\\n    postMessage(responseMessage, arr);\\\\r\\\\n};\\\\r\\\\nvar createProgressResponseMessage = function (progress) {\\\\r\\\\n    var responseMessage = new ResponseMessage(progress);\\\\r\\\\n    responseMessage.done = false;\\\\r\\\\n    return responseMessage;\\\\r\\\\n};\\\\r\\\\nvar validateWorker = function () {\\\\r\\\\n    if (txtReaderWorker === null) {\\\\r\\\\n        respondMessage(new ResponseMessage(false, \\\'File has not been loaded into the worker, need to loadFile first.\\\'));\\\\r\\\\n        return false;\\\\r\\\\n    }\\\\r\\\\n    return true;\\\\r\\\\n};\\\\r\\\\nvar mergeUint8Array = function (x, y) {\\\\r\\\\n    if (x.byteLength === 0) {\\\\r\\\\n        return y;\\\\r\\\\n    }\\\\r\\\\n    if (y.byteLength === 0) {\\\\r\\\\n        return x;\\\\r\\\\n    }\\\\r\\\\n    var z = new Uint8Array(x.byteLength + y.byteLength);\\\\r\\\\n    z.set(x, 0);\\\\r\\\\n    z.set(y, x.byteLength);\\\\r\\\\n    return z;\\\\r\\\\n};\\\\r\\\\nvar isLineWithinLinesRange = function (line, linesRange) {\\\\r\\\\n    var linesEnd = getLinesRangeEnd(linesRange);\\\\r\\\\n    return line >= linesRange.start && line <= linesEnd;\\\\r\\\\n};\\\\r\\\\nvar getLinesRangeEnd = function (linesRange) {\\\\r\\\\n    return linesRange.count !== undefined ? linesRange.start + linesRange.count - 1 : linesRange.end;\\\\r\\\\n};\\\\r\\\\nvar getLinesRangeCount = function (linesRange) {\\\\r\\\\n    return linesRange.count !== undefined ? linesRange.count : linesRange.end - linesRange.start + 1;\\\\r\\\\n};\\\\r\\\\nvar getLinesRangeStart = function (lineItem) {\\\\r\\\\n    return typeof lineItem === \\\'number\\\' ? lineItem : lineItem.start;\\\\r\\\\n};\\\\r\\\\nvar getStartCountForSporadicLineItem = function (item) {\\\\r\\\\n    if (typeof item === \\\'number\\\') {\\\\r\\\\n        return {\\\\r\\\\n            start: item,\\\\r\\\\n            count: 1\\\\r\\\\n        };\\\\r\\\\n    }\\\\r\\\\n    else {\\\\r\\\\n        if (item.end !== undefined) {\\\\r\\\\n            return {\\\\r\\\\n                start: item.start,\\\\r\\\\n                count: item.end - item.start + 1\\\\r\\\\n            };\\\\r\\\\n        }\\\\r\\\\n        else {\\\\r\\\\n            return item;\\\\r\\\\n        }\\\\r\\\\n    }\\\\r\\\\n};\\\\r\\\\nself.addEventListener(\\\'message\\\', function (event) {\\\\r\\\\n    var req = event.data;\\\\r\\\\n    if (verboseLogging) {\\\\r\\\\n        console.log(\\\'Worker thread received a message from main thread: \\\\\\\\r\\\\\\\\n\\\', event.data);\\\\r\\\\n    }\\\\r\\\\n    if (currentTaskId !== null) {\\\\r\\\\n        throw (\\\'The worker thread is busy.\\\');\\\\r\\\\n    }\\\\r\\\\n    currentTaskId = req.taskId;\\\\r\\\\n    switch (req.action) {\\\\r\\\\n        case \\\'loadFile\\\':\\\\r\\\\n            txtReaderWorker = new TxtReaderWorker(req.data.file, req.data.config);\\\\r\\\\n            break;\\\\r\\\\n        case \\\'enableVerbose\\\':\\\\r\\\\n            verboseLogging = true;\\\\r\\\\n            respondMessage(new ResponseMessage(true));\\\\r\\\\n            break;\\\\r\\\\n        case \\\'setChunkSize\\\':\\\\r\\\\n            if (typeof req.data !== \\\'number\\\' || req.data < 1) {\\\\r\\\\n                respondMessage(new ResponseMessage(false, \\\'Invalid CHUNK_SIZE, must be greater than 1.\\\'));\\\\r\\\\n                return;\\\\r\\\\n            }\\\\r\\\\n            if (txtReaderWorker) {\\\\r\\\\n                txtReaderWorker.CHUNK_SIZE = req.data;\\\\r\\\\n            }\\\\r\\\\n            DEFAULT_CHUNK_SIZE = req.data;\\\\r\\\\n            respondMessage(new ResponseMessage(DEFAULT_CHUNK_SIZE));\\\\r\\\\n            break;\\\\r\\\\n        case \\\'getLines\\\':\\\\r\\\\n            if (validateWorker()) {\\\\r\\\\n                txtReaderWorker.getLines(req.data.start, req.data.count);\\\\r\\\\n            }\\\\r\\\\n            break;\\\\r\\\\n        case \\\'getSporadicLines\\\':\\\\r\\\\n            if (validateWorker()) {\\\\r\\\\n                txtReaderWorker.getSporadicLines(req.data.sporadicLinesMap, req.data.decode);\\\\r\\\\n            }\\\\r\\\\n            break;\\\\r\\\\n        case \\\'iterateLines\\\':\\\\r\\\\n            if (validateWorker()) {\\\\r\\\\n                txtReaderWorker.iterateLines(req.data);\\\\r\\\\n            }\\\\r\\\\n            break;\\\\r\\\\n        case \\\'iterateSporadicLines\\\':\\\\r\\\\n            if (validateWorker()) {\\\\r\\\\n                txtReaderWorker.iterateSporadicLines(req.data.config, req.data.lines);\\\\r\\\\n            }\\\\r\\\\n            break;\\\\r\\\\n        case \\\'sniffLines\\\':\\\\r\\\\n            sniffWorker = new TxtReaderWorker(req.data.file, undefined, {\\\\r\\\\n                lineNumber: req.data.lineNumber,\\\\r\\\\n                decode: req.data.decode\\\\r\\\\n            });\\\\r\\\\n            break;\\\\r\\\\n    }\\\\r\\\\n});\\\\r\\\\nvar ResponseMessage = /** @class */ (function () {\\\\r\\\\n    function ResponseMessage(x, y, z) {\\\\r\\\\n        this.taskId = currentTaskId;\\\\r\\\\n        if (arguments.length === 1) {\\\\r\\\\n            this.success = true;\\\\r\\\\n            this.message = \\\'\\\';\\\\r\\\\n            this.result = x;\\\\r\\\\n        }\\\\r\\\\n        else if (arguments.length === 2) {\\\\r\\\\n            switch (typeof x) {\\\\r\\\\n                case \\\'boolean\\\':\\\\r\\\\n                    this.success = x;\\\\r\\\\n                    this.message = y;\\\\r\\\\n                    this.result = null;\\\\r\\\\n                    break;\\\\r\\\\n                default:\\\\r\\\\n                    this.success = true;\\\\r\\\\n                    this.message = x;\\\\r\\\\n                    this.result = y;\\\\r\\\\n            }\\\\r\\\\n        }\\\\r\\\\n        else {\\\\r\\\\n            this.success = x;\\\\r\\\\n            this.message = y;\\\\r\\\\n            this.result = z;\\\\r\\\\n        }\\\\r\\\\n        this.done = true;\\\\r\\\\n    }\\\\r\\\\n    return ResponseMessage;\\\\r\\\\n}());\\\\r\\\\nvar Iterator = /** @class */ (function () {\\\\r\\\\n    function Iterator() {\\\\r\\\\n        this.lineView = new Uint8Array(0);\\\\r\\\\n        this.lastViewEndsWithCR = false;\\\\r\\\\n        this.onEachLine = null;\\\\r\\\\n        this.eachLineScope = null;\\\\r\\\\n        this.offset = 0;\\\\r\\\\n        this.createMap = false;\\\\r\\\\n        this.endOffset = 0;\\\\r\\\\n        this.linesToIterate = 0;\\\\r\\\\n        this.linesProcessed = 0;\\\\r\\\\n        this.currentLineNumber = 1;\\\\r\\\\n        this.startLineNumber = 0;\\\\r\\\\n        this.lastProgress = null;\\\\r\\\\n        this.processedViewLength = 0;\\\\r\\\\n        this.lineBreakLength = 0;\\\\r\\\\n        this.map = [];\\\\r\\\\n        this.lastMappedProgress = null;\\\\r\\\\n        this.sporadicProcessed = 0;\\\\r\\\\n        this.sporadicLinesMap = [];\\\\r\\\\n        this.isSporadicIterate = false;\\\\r\\\\n    }\\\\r\\\\n    Iterator.prototype.shouldBreak = function () {\\\\r\\\\n        if (this.isPartialIterate() && (this.linesProcessed === this.linesToIterate || this.sporadicProcessed === this.linesToIterate)) {\\\\r\\\\n            return true;\\\\r\\\\n        }\\\\r\\\\n        else {\\\\r\\\\n            return false;\\\\r\\\\n        }\\\\r\\\\n    };\\\\r\\\\n    Iterator.prototype.isPartialIterate = function () {\\\\r\\\\n        // is partial iterate or is sporadic iterate\\\\r\\\\n        return this.linesToIterate > 0;\\\\r\\\\n    };\\\\r\\\\n    Iterator.prototype.hitLine = function (lineData) {\\\\r\\\\n        var isPartialIterate = this.isPartialIterate();\\\\r\\\\n        var progress = 0;\\\\r\\\\n        if (!isPartialIterate ||\\\\r\\\\n            (isPartialIterate && this.currentLineNumber >= this.startLineNumber && !this.isSporadicIterate) ||\\\\r\\\\n            this.isSporadicIterate) {\\\\r\\\\n            // complete iterate\\\\r\\\\n            // continuous partial iterate and within range\\\\r\\\\n            // sporadic iterate\\\\r\\\\n            var match = false;\\\\r\\\\n            if (isPartialIterate) {\\\\r\\\\n                if (!this.isSporadicIterate) {\\\\r\\\\n                    this.linesProcessed++;\\\\r\\\\n                    match = true;\\\\r\\\\n                    progress = Math.round(this.linesProcessed / this.linesToIterate * 10000) / 100;\\\\r\\\\n                }\\\\r\\\\n                else {\\\\r\\\\n                    progress = Math.round(this.sporadicProcessed / this.linesToIterate * 10000) / 100;\\\\r\\\\n                    var first = this.sporadicLinesMap[0];\\\\r\\\\n                    if (typeof first === \\\'number\\\') {\\\\r\\\\n                        if (first === this.currentLineNumber) {\\\\r\\\\n                            this.sporadicLinesMap.splice(0, 1);\\\\r\\\\n                            match = true;\\\\r\\\\n                        }\\\\r\\\\n                    }\\\\r\\\\n                    else {\\\\r\\\\n                        if (first.count !== undefined) {\\\\r\\\\n                            if (this.currentLineNumber >= first.start && this.currentLineNumber <= first.start + first.count - 1) {\\\\r\\\\n                                // within range\\\\r\\\\n                                if (first.count === 1) {\\\\r\\\\n                                    this.sporadicLinesMap.splice(0, 1);\\\\r\\\\n                                }\\\\r\\\\n                                else {\\\\r\\\\n                                    first.start++;\\\\r\\\\n                                    first.count--;\\\\r\\\\n                                }\\\\r\\\\n                                match = true;\\\\r\\\\n                            }\\\\r\\\\n                        }\\\\r\\\\n                        else {\\\\r\\\\n                            if (this.currentLineNumber >= first.start && this.currentLineNumber <= first.end) {\\\\r\\\\n                                // within range\\\\r\\\\n                                if (first.start === first.end) {\\\\r\\\\n                                    this.sporadicLinesMap.splice(0, 1);\\\\r\\\\n                                }\\\\r\\\\n                                else {\\\\r\\\\n                                    first.start++;\\\\r\\\\n                                }\\\\r\\\\n                                match = true;\\\\r\\\\n                            }\\\\r\\\\n                        }\\\\r\\\\n                    }\\\\r\\\\n                    if (match) {\\\\r\\\\n                        this.sporadicProcessed++;\\\\r\\\\n                    }\\\\r\\\\n                }\\\\r\\\\n            }\\\\r\\\\n            else {\\\\r\\\\n                match = true;\\\\r\\\\n                this.linesProcessed++;\\\\r\\\\n                progress = Math.round(this.processedViewLength / this.endOffset * 10000) / 100;\\\\r\\\\n                if (this.createMap) {\\\\r\\\\n                    var currentProgress = Math.round(progress);\\\\r\\\\n                    if (this.lastMappedProgress === null ||\\\\r\\\\n                        this.lastMappedProgress < currentProgress) {\\\\r\\\\n                        this.lastMappedProgress = currentProgress;\\\\r\\\\n                        this.map.push({\\\\r\\\\n                            line: this.currentLineNumber,\\\\r\\\\n                            offset: this.processedViewLength\\\\r\\\\n                        });\\\\r\\\\n                    }\\\\r\\\\n                }\\\\r\\\\n            }\\\\r\\\\n            if (this.onEachLineInternal && match) {\\\\r\\\\n                if (lineData.buffer.byteLength != lineData.byteLength) {\\\\r\\\\n                    lineData = new Uint8Array(lineData);\\\\r\\\\n                }\\\\r\\\\n                this.onEachLineInternal.call(this, lineData);\\\\r\\\\n            }\\\\r\\\\n            if (this.onEachLine !== null && match) {\\\\r\\\\n                if (lineData.buffer.byteLength != lineData.byteLength) {\\\\r\\\\n                    lineData = new Uint8Array(lineData);\\\\r\\\\n                }\\\\r\\\\n                this.onEachLine.call(this.eachLineScope, lineData, progress, this.currentLineNumber);\\\\r\\\\n            }\\\\r\\\\n        }\\\\r\\\\n        if (isPartialIterate) {\\\\r\\\\n            if (this.shouldReportProgress(progress)) {\\\\r\\\\n                this.lastProgress = progress;\\\\r\\\\n                respondMessage(createProgressResponseMessage(progress < 100 ? progress : 100));\\\\r\\\\n            }\\\\r\\\\n        }\\\\r\\\\n        this.processedViewLength += lineData.length + this.lineBreakLength;\\\\r\\\\n        this.currentLineNumber++;\\\\r\\\\n    };\\\\r\\\\n    Iterator.prototype.shouldReportProgress = function (currentProgress) {\\\\r\\\\n        if (this.lastProgress === null) {\\\\r\\\\n            return true;\\\\r\\\\n        }\\\\r\\\\n        else if (currentProgress - this.lastProgress > 5) {\\\\r\\\\n            return true;\\\\r\\\\n        }\\\\r\\\\n        else {\\\\r\\\\n            return false;\\\\r\\\\n        }\\\\r\\\\n    };\\\\r\\\\n    Iterator.prototype.bindEachLineFromConfig = function (config) {\\\\r\\\\n        this.onEachLine = new Function(\\\'return \\\' + config.eachLine)();\\\\r\\\\n        if (this.eachLineScope === null) {\\\\r\\\\n            // for sporadic iterate, eachLineScope will be set explicitly\\\\r\\\\n            this.eachLineScope = config.scope;\\\\r\\\\n        }\\\\r\\\\n        this.eachLineScope[\\\'decode\\\'] = function (value) {\\\\r\\\\n            return utf8decoder.decode(value);\\\\r\\\\n        };\\\\r\\\\n    };\\\\r\\\\n    return Iterator;\\\\r\\\\n}());\\\\r\\\\nvar TxtReaderWorker = /** @class */ (function () {\\\\r\\\\n    function TxtReaderWorker(file, onNewLineConfig, sniffConfig) {\\\\r\\\\n        var _this_1 = this;\\\\r\\\\n        if (Object.prototype.toString.call(file).toLowerCase() !== \\\'[object file]\\\') {\\\\r\\\\n            respondMessage(new ResponseMessage(false, \\\'Invalid file object\\\'));\\\\r\\\\n            return;\\\\r\\\\n        }\\\\r\\\\n        this.CHUNK_SIZE = DEFAULT_CHUNK_SIZE;\\\\r\\\\n        this.file = file;\\\\r\\\\n        this.lineCount = 0;\\\\r\\\\n        this.quickSearchMap = [];\\\\r\\\\n        this.fr = new FileReader();\\\\r\\\\n        this.fr.onload = function () {\\\\r\\\\n            var view = new Uint8Array(_this_1.fr.result);\\\\r\\\\n            var iterator = _this_1.iterator;\\\\r\\\\n            while (view.length > 0) {\\\\r\\\\n                // first CR (0x0D, \\\\\\\\r) position in the view\\\\r\\\\n                var crIndex = view.indexOf(13);\\\\r\\\\n                // first LF (0x0A, \\\\\\\\n) position in the view\\\\r\\\\n                var lfIndex = view.indexOf(10);\\\\r\\\\n                // for CRLF linebreakLength would be 2, otherwise the value would be 1.\\\\r\\\\n                var lineBreakIndex = void 0;\\\\r\\\\n                // If merge all view to lineView\\\\r\\\\n                var mergeAll = false;\\\\r\\\\n                // If current view ends with CR\\\\r\\\\n                var endsWithCR = false;\\\\r\\\\n                if (crIndex > 0 && (lfIndex === -1 || crIndex < lfIndex)) {\\\\r\\\\n                    // CR is hit before LF in the view or there is only CR hit in the view\\\\r\\\\n                    // CR is in the middle or end\\\\r\\\\n                    if (crIndex < view.length - 1) {\\\\r\\\\n                        // CR in the middle\\\\r\\\\n                        if (view[crIndex + 1] === 10) {\\\\r\\\\n                            // CRLF\\\\r\\\\n                            lineBreakIndex = crIndex;\\\\r\\\\n                            iterator.lineBreakLength = 2;\\\\r\\\\n                        }\\\\r\\\\n                        else {\\\\r\\\\n                            // CR only in the middle\\\\r\\\\n                            lineBreakIndex = crIndex;\\\\r\\\\n                            iterator.lineBreakLength = 1;\\\\r\\\\n                        }\\\\r\\\\n                    }\\\\r\\\\n                    else {\\\\r\\\\n                        // CR in the end, do MERGEALL first since not sure the linebreak is CR or CRLF\\\\r\\\\n                        endsWithCR = true;\\\\r\\\\n                        mergeAll = true;\\\\r\\\\n                    }\\\\r\\\\n                }\\\\r\\\\n                else if (crIndex === 0) {\\\\r\\\\n                    // CR is the first byte\\\\r\\\\n                    if (view.length > 1) {\\\\r\\\\n                        if (view[1] === 10) {\\\\r\\\\n                            // CRLF at beginning\\\\r\\\\n                            lineBreakIndex = crIndex;\\\\r\\\\n                            iterator.lineBreakLength = 2;\\\\r\\\\n                        }\\\\r\\\\n                        else {\\\\r\\\\n                            // CR only at beginning\\\\r\\\\n                            lineBreakIndex = crIndex;\\\\r\\\\n                            iterator.lineBreakLength = 1;\\\\r\\\\n                        }\\\\r\\\\n                    }\\\\r\\\\n                    else {\\\\r\\\\n                        // rare scenario: view length is 1 and the content is CR, CR is not only the first byte but also the last byte\\\\r\\\\n                        // do MERGEALL first since not sure the linebreak is CR or CRLF\\\\r\\\\n                        endsWithCR = true;\\\\r\\\\n                        mergeAll = true;\\\\r\\\\n                    }\\\\r\\\\n                }\\\\r\\\\n                else {\\\\r\\\\n                    // no CR in the view or LF is hit before CR\\\\r\\\\n                    if (lfIndex > 0) {\\\\r\\\\n                        // LF is in the middle or end, no need to check the CRLF scenario since no CR is found before LF postion\\\\r\\\\n                        lineBreakIndex = lfIndex;\\\\r\\\\n                        iterator.lineBreakLength = 1;\\\\r\\\\n                    }\\\\r\\\\n                    else if (lfIndex === 0) {\\\\r\\\\n                        // LF is the first byte, need to check if the last byte of lineView is CR\\\\r\\\\n                        iterator.lineBreakLength = iterator.lastViewEndsWithCR ? 2 : 1;\\\\r\\\\n                        iterator.hitLine(iterator.lastViewEndsWithCR ? iterator.lineView.slice(0, iterator.lineView.length - 1) : iterator.lineView);\\\\r\\\\n                        if (iterator.shouldBreak()) {\\\\r\\\\n                            break;\\\\r\\\\n                        }\\\\r\\\\n                        iterator.lineView = new Uint8Array(0);\\\\r\\\\n                        view = new Uint8Array(_this_1.fr.result, 1 + view.byteOffset);\\\\r\\\\n                        iterator.lastViewEndsWithCR = false;\\\\r\\\\n                        continue;\\\\r\\\\n                    }\\\\r\\\\n                    else {\\\\r\\\\n                        // no LF found\\\\r\\\\n                        mergeAll = true;\\\\r\\\\n                    }\\\\r\\\\n                }\\\\r\\\\n                if (!mergeAll) {\\\\r\\\\n                    if (iterator.lastViewEndsWithCR) {\\\\r\\\\n                        // lineView is like: ****CR, just treat **** as a new line, no need to check if the current view starts with LF since it is handled by LF first byte scenario\\\\r\\\\n                        iterator.hitLine(iterator.lineView.slice(0, iterator.lineView.length - 1));\\\\r\\\\n                        if (iterator.shouldBreak()) {\\\\r\\\\n                            break;\\\\r\\\\n                        }\\\\r\\\\n                        // treat the view as a new line\\\\r\\\\n                        iterator.hitLine(view.slice(0, lineBreakIndex));\\\\r\\\\n                        if (iterator.shouldBreak()) {\\\\r\\\\n                            break;\\\\r\\\\n                        }\\\\r\\\\n                        // reset lastViewEndsWithCR to prevent it being treated again for next view\\\\r\\\\n                        iterator.lastViewEndsWithCR = false;\\\\r\\\\n                    }\\\\r\\\\n                    else {\\\\r\\\\n                        // merge the view line into lineView\\\\r\\\\n                        iterator.lineView = mergeUint8Array(iterator.lineView, view.slice(0, lineBreakIndex));\\\\r\\\\n                        // treat the lineView as a whole line\\\\r\\\\n                        iterator.hitLine(iterator.lineView);\\\\r\\\\n                        if (iterator.shouldBreak()) {\\\\r\\\\n                            break;\\\\r\\\\n                        }\\\\r\\\\n                    }\\\\r\\\\n                    // clear lineView\\\\r\\\\n                    iterator.lineView = new Uint8Array(0);\\\\r\\\\n                    // remove the processed view\\\\r\\\\n                    view = new Uint8Array(_this_1.fr.result, view.byteOffset + lineBreakIndex + iterator.lineBreakLength);\\\\r\\\\n                }\\\\r\\\\n                else {\\\\r\\\\n                    // do merge all, which means no CR or LF found\\\\r\\\\n                    if (iterator.lastViewEndsWithCR) {\\\\r\\\\n                        // lineView is like: ****CR, just treat **** as a new line\\\\r\\\\n                        iterator.lineBreakLength = 1;\\\\r\\\\n                        iterator.hitLine(iterator.lineView.slice(0, iterator.lineView.length - 1));\\\\r\\\\n                        if (iterator.shouldBreak()) {\\\\r\\\\n                            break;\\\\r\\\\n                        }\\\\r\\\\n                        // clear lineView\\\\r\\\\n                        iterator.lineView = new Uint8Array(0);\\\\r\\\\n                    }\\\\r\\\\n                    // merge the view to lineView\\\\r\\\\n                    iterator.lineView = mergeUint8Array(iterator.lineView, view);\\\\r\\\\n                    iterator.lastViewEndsWithCR = endsWithCR;\\\\r\\\\n                    break; // break the while as all rest view is processed\\\\r\\\\n                }\\\\r\\\\n            }\\\\r\\\\n            if (!iterator.isPartialIterate()) {\\\\r\\\\n                var progress = Math.round(iterator.offset / _this_1.file.size * 10000) / 100;\\\\r\\\\n                respondMessage(createProgressResponseMessage(progress < 100 ? progress : 100));\\\\r\\\\n            }\\\\r\\\\n            iterator.lineBreakLength = 0;\\\\r\\\\n            if (_this_1.iterator.isSporadicIterate) {\\\\r\\\\n                _this_1.seekSporadic();\\\\r\\\\n            }\\\\r\\\\n            else {\\\\r\\\\n                iterator.offset += _this_1.CHUNK_SIZE;\\\\r\\\\n                _this_1.seek();\\\\r\\\\n            }\\\\r\\\\n        };\\\\r\\\\n        this.iterator = new Iterator();\\\\r\\\\n        this.iterator.createMap = true;\\\\r\\\\n        if (sniffConfig) {\\\\r\\\\n            this.sniffLines = [];\\\\r\\\\n            this.iterator.linesToIterate = sniffConfig.lineNumber;\\\\r\\\\n            this.iterator.createMap = false;\\\\r\\\\n        }\\\\r\\\\n        this.iterator.endOffset = this.file.size;\\\\r\\\\n        if (onNewLineConfig) {\\\\r\\\\n            this.iterator.bindEachLineFromConfig(this.stringToFunction(onNewLineConfig));\\\\r\\\\n        }\\\\r\\\\n        this.iterateLinesInternal(function (line) {\\\\r\\\\n            if (!sniffConfig) {\\\\r\\\\n                _this_1.lineCount++;\\\\r\\\\n            }\\\\r\\\\n            else {\\\\r\\\\n                _this_1.sniffLines.push(sniffConfig.decode ? utf8decoder.decode(line) : line);\\\\r\\\\n            }\\\\r\\\\n        }, function () {\\\\r\\\\n            if (!sniffConfig) {\\\\r\\\\n                _this_1.quickSearchMap = _this_1.iterator.map;\\\\r\\\\n                var result = {\\\\r\\\\n                    lineCount: _this_1.lineCount\\\\r\\\\n                };\\\\r\\\\n                if (onNewLineConfig) {\\\\r\\\\n                    result.scope = _this_1.removeFunctionsFromObject(_this_1.iterator.eachLineScope);\\\\r\\\\n                }\\\\r\\\\n                respondMessage(new ResponseMessage(result));\\\\r\\\\n            }\\\\r\\\\n            else {\\\\r\\\\n                // sniff complete\\\\r\\\\n                respondMessage(new ResponseMessage(_this_1.sniffLines));\\\\r\\\\n                _this_1.sniffLines = [];\\\\r\\\\n                delete _this_1.sniffLines;\\\\r\\\\n                sniffWorker = null;\\\\r\\\\n            }\\\\r\\\\n        });\\\\r\\\\n    }\\\\r\\\\n    TxtReaderWorker.prototype.setPartialIterator = function (start, count) {\\\\r\\\\n        if (start < 1 || start > this.lineCount) {\\\\r\\\\n            respondMessage(new ResponseMessage(false, \\\'Start line number is invalid\\\'));\\\\r\\\\n            return false;\\\\r\\\\n        }\\\\r\\\\n        else {\\\\r\\\\n            var endLineNumber = start + count - 1;\\\\r\\\\n            endLineNumber = endLineNumber > this.lineCount ? this.lineCount : endLineNumber;\\\\r\\\\n            for (var i = 0; i < this.quickSearchMap.length; i++) {\\\\r\\\\n                if (start >= this.quickSearchMap[i].line && (i === this.quickSearchMap.length - 1 || start < this.quickSearchMap[i + 1].line)) {\\\\r\\\\n                    this.iterator.offset = this.quickSearchMap[i].offset;\\\\r\\\\n                    this.iterator.currentLineNumber = this.quickSearchMap[i].line;\\\\r\\\\n                }\\\\r\\\\n                if (endLineNumber < this.quickSearchMap[i].line && (i === 0 || endLineNumber >= this.quickSearchMap[i - 1].line)) {\\\\r\\\\n                    this.iterator.endOffset = this.quickSearchMap[i].offset;\\\\r\\\\n                }\\\\r\\\\n                else {\\\\r\\\\n                    this.iterator.endOffset = this.file.size;\\\\r\\\\n                }\\\\r\\\\n            }\\\\r\\\\n            this.iterator.linesToIterate = count;\\\\r\\\\n            this.iterator.startLineNumber = start;\\\\r\\\\n            return true;\\\\r\\\\n        }\\\\r\\\\n    };\\\\r\\\\n    TxtReaderWorker.prototype.iterateLinesInternal = function (onNewLineFunc, onSeekComplete) {\\\\r\\\\n        this.iterator.onEachLineInternal = onNewLineFunc;\\\\r\\\\n        if (onSeekComplete) {\\\\r\\\\n            this.iterator.onSeekComplete = onSeekComplete;\\\\r\\\\n        }\\\\r\\\\n        this.seek();\\\\r\\\\n    };\\\\r\\\\n    TxtReaderWorker.prototype._iterateLines = function (config, start, count, onSeekComplete) {\\\\r\\\\n        var _this = this;\\\\r\\\\n        this.iterator.offset = 0;\\\\r\\\\n        this.iterator.endOffset = this.file.size;\\\\r\\\\n        this.iterator.bindEachLineFromConfig(config);\\\\r\\\\n        this.iterator.onSeekComplete = function () {\\\\r\\\\n            this.eachLineScope = _this.removeFunctionsFromObject(this.eachLineScope);\\\\r\\\\n            onSeekComplete();\\\\r\\\\n        };\\\\r\\\\n        if (start !== null && count !== null) {\\\\r\\\\n            if (this.setPartialIterator(start, count)) {\\\\r\\\\n                this.seek();\\\\r\\\\n            }\\\\r\\\\n            else {\\\\r\\\\n                return;\\\\r\\\\n            }\\\\r\\\\n        }\\\\r\\\\n        else {\\\\r\\\\n            this.seek();\\\\r\\\\n        }\\\\r\\\\n    };\\\\r\\\\n    TxtReaderWorker.prototype.removeFunctionsFromObject = function (obj) {\\\\r\\\\n        if (typeof obj === \\\'object\\\') {\\\\r\\\\n            for (var i in obj) {\\\\r\\\\n                if (typeof obj[i] === \\\'function\\\') {\\\\r\\\\n                    delete obj[i];\\\\r\\\\n                }\\\\r\\\\n                else if (typeof obj[i] === \\\'object\\\') {\\\\r\\\\n                    this.removeFunctionsFromObject(obj[i]);\\\\r\\\\n                }\\\\r\\\\n            }\\\\r\\\\n        }\\\\r\\\\n        return obj;\\\\r\\\\n    };\\\\r\\\\n    TxtReaderWorker.prototype.stringToFunction = function (config) {\\\\r\\\\n        var functionMap = config.functionMap;\\\\r\\\\n        if (functionMap.length) {\\\\r\\\\n            for (var i = 0; i < functionMap.length; i++) {\\\\r\\\\n                var functionString = eval(\\\\\\\"config.scope\\\\\\\" + functionMap[i] + \\\\\\\".toString()\\\\\\\");\\\\r\\\\n                eval(\\\\\\\"config.scope\\\\\\\" + functionMap[i] + \\\\\\\"=\\\\\\\" + functionString);\\\\r\\\\n            }\\\\r\\\\n        }\\\\r\\\\n        return config;\\\\r\\\\n    };\\\\r\\\\n    TxtReaderWorker.prototype.iterateLines = function (data) {\\\\r\\\\n        var _this_1 = this;\\\\r\\\\n        var config = this.stringToFunction(data.config);\\\\r\\\\n        this._iterateLines(config, data.start, data.count, function () {\\\\r\\\\n            respondMessage(new ResponseMessage(_this_1.iterator.eachLineScope));\\\\r\\\\n        });\\\\r\\\\n    };\\\\r\\\\n    TxtReaderWorker.prototype.setSporadicIterator = function (sporadicLinesMap) {\\\\r\\\\n        sporadicLinesMap = this.sortAndMergeLineMap(sporadicLinesMap);\\\\r\\\\n        var sporadicTotal = 0;\\\\r\\\\n        for (var i = 0; i < sporadicLinesMap.length; i++) {\\\\r\\\\n            if (typeof sporadicLinesMap[i] === \\\'number\\\') {\\\\r\\\\n                sporadicTotal++;\\\\r\\\\n            }\\\\r\\\\n            else {\\\\r\\\\n                sporadicTotal += getLinesRangeCount(sporadicLinesMap[i]);\\\\r\\\\n            }\\\\r\\\\n        }\\\\r\\\\n        this.iterator.linesToIterate = sporadicTotal;\\\\r\\\\n        this.iterator.endOffset = this.file.size;\\\\r\\\\n        this.iterator.isSporadicIterate = true;\\\\r\\\\n        this.iterator.sporadicLinesMap = sporadicLinesMap;\\\\r\\\\n        this.seekSporadic();\\\\r\\\\n    };\\\\r\\\\n    TxtReaderWorker.prototype.getSporadicLines = function (sporadicLinesMap, decode) {\\\\r\\\\n        sporadicLinesMap = this.sortAndMergeLineMap(sporadicLinesMap);\\\\r\\\\n        var result = [];\\\\r\\\\n        this.iterator.onEachLineInternal = function (line) {\\\\r\\\\n            result.push({\\\\r\\\\n                lineNumber: this.currentLineNumber,\\\\r\\\\n                value: decode ? utf8decoder.decode(line) : line\\\\r\\\\n            });\\\\r\\\\n        };\\\\r\\\\n        this.iterator.onSeekComplete = function () {\\\\r\\\\n            respondMessage(new ResponseMessage(result));\\\\r\\\\n        };\\\\r\\\\n        this.setSporadicIterator(sporadicLinesMap);\\\\r\\\\n    };\\\\r\\\\n    TxtReaderWorker.prototype.iterateSporadicLines = function (config, sporadicLinesMap) {\\\\r\\\\n        sporadicLinesMap = this.sortAndMergeLineMap(sporadicLinesMap);\\\\r\\\\n        config = this.stringToFunction(config);\\\\r\\\\n        var _this = this;\\\\r\\\\n        this.iterator.bindEachLineFromConfig(config);\\\\r\\\\n        this.iterator.onSeekComplete = function () {\\\\r\\\\n            this.eachLineScope = _this.removeFunctionsFromObject(this.eachLineScope);\\\\r\\\\n            respondMessage(new ResponseMessage(this.eachLineScope));\\\\r\\\\n        };\\\\r\\\\n        this.setSporadicIterator(sporadicLinesMap);\\\\r\\\\n    };\\\\r\\\\n    TxtReaderWorker.prototype.seek = function () {\\\\r\\\\n        var finishDueToLinesToIterateReached = this.iterator.linesToIterate > 0 && this.iterator.linesProcessed === this.iterator.linesToIterate;\\\\r\\\\n        if (this.iterator.offset >= this.iterator.endOffset || finishDueToLinesToIterateReached) {\\\\r\\\\n            respondMessage(createProgressResponseMessage(100));\\\\r\\\\n            if (this.iterator.lineView.byteLength && !finishDueToLinesToIterateReached) {\\\\r\\\\n                this.iterator.hitLine(this.iterator.lineView);\\\\r\\\\n                this.iterator.lineView = new Uint8Array(0);\\\\r\\\\n            }\\\\r\\\\n            if (this.iterator.onSeekComplete) {\\\\r\\\\n                this.iterator.onSeekComplete.call(this.iterator);\\\\r\\\\n            }\\\\r\\\\n            this.iterator = new Iterator();\\\\r\\\\n        }\\\\r\\\\n        else {\\\\r\\\\n            var slice = this.file.slice(this.iterator.offset, this.iterator.offset + this.CHUNK_SIZE);\\\\r\\\\n            this.fr.readAsArrayBuffer(slice);\\\\r\\\\n        }\\\\r\\\\n    };\\\\r\\\\n    TxtReaderWorker.prototype.seekSporadic = function () {\\\\r\\\\n        if (this.iterator.sporadicProcessed === this.iterator.linesToIterate) {\\\\r\\\\n            complete.call(this);\\\\r\\\\n        }\\\\r\\\\n        else {\\\\r\\\\n            var first = this.iterator.sporadicLinesMap[0];\\\\r\\\\n            var start = getLinesRangeStart(first);\\\\r\\\\n            if (this.iterator.lineView.byteLength && this.iterator.currentLineNumber === start) {\\\\r\\\\n                this.iterator.offset += this.CHUNK_SIZE;\\\\r\\\\n                if (this.iterator.offset >= this.iterator.endOffset) {\\\\r\\\\n                    this.iterator.hitLine(this.iterator.lineView);\\\\r\\\\n                    this.iterator.lineView = new Uint8Array(0);\\\\r\\\\n                    if (this.iterator.sporadicProcessed === this.iterator.linesToIterate) {\\\\r\\\\n                        complete.call(this);\\\\r\\\\n                    }\\\\r\\\\n                }\\\\r\\\\n                else {\\\\r\\\\n                    var slice = this.file.slice(this.iterator.offset, this.iterator.offset + this.CHUNK_SIZE);\\\\r\\\\n                    this.fr.readAsArrayBuffer(slice);\\\\r\\\\n                    return;\\\\r\\\\n                }\\\\r\\\\n            }\\\\r\\\\n            else if (this.iterator.sporadicLinesMap.length > 0) {\\\\r\\\\n                for (var i = 0; i < this.quickSearchMap.length; i++) {\\\\r\\\\n                    var mapStart = this.quickSearchMap[i].line;\\\\r\\\\n                    var mapEnd = i === this.quickSearchMap.length - 1 ? this.lineCount : this.quickSearchMap[i + 1].line - 1;\\\\r\\\\n                    if (start >= mapStart && start <= mapEnd) {\\\\r\\\\n                        var offset = this.quickSearchMap[i].offset;\\\\r\\\\n                        this.iterator.offset = offset;\\\\r\\\\n                        var slice = this.file.slice(offset, offset + this.CHUNK_SIZE);\\\\r\\\\n                        this.iterator.currentLineNumber = this.quickSearchMap[i].line;\\\\r\\\\n                        this.fr.readAsArrayBuffer(slice);\\\\r\\\\n                        return;\\\\r\\\\n                    }\\\\r\\\\n                }\\\\r\\\\n                // out of range\\\\r\\\\n                complete.call(this);\\\\r\\\\n            }\\\\r\\\\n        }\\\\r\\\\n        function complete() {\\\\r\\\\n            respondMessage(createProgressResponseMessage(100));\\\\r\\\\n            if (this.iterator.onSeekComplete) {\\\\r\\\\n                this.iterator.onSeekComplete.call(this.iterator);\\\\r\\\\n            }\\\\r\\\\n            this.iterator = new Iterator();\\\\r\\\\n        }\\\\r\\\\n    };\\\\r\\\\n    TxtReaderWorker.prototype._getLines = function (start, count, onSeekCompleteFunc) {\\\\r\\\\n        if (this.setPartialIterator(start, count)) {\\\\r\\\\n            var lines_1 = [];\\\\r\\\\n            var linesBuffer_1 = [];\\\\r\\\\n            this.iterateLinesInternal(function (line) {\\\\r\\\\n                lines_1.push(line);\\\\r\\\\n                if (useTransferrable) {\\\\r\\\\n                    linesBuffer_1.push(line.buffer);\\\\r\\\\n                }\\\\r\\\\n            }, function () {\\\\r\\\\n                setTimeout(function () {\\\\r\\\\n                    onSeekCompleteFunc(lines_1, linesBuffer_1);\\\\r\\\\n                }, 0);\\\\r\\\\n            });\\\\r\\\\n        }\\\\r\\\\n    };\\\\r\\\\n    TxtReaderWorker.prototype.getLines = function (start, count) {\\\\r\\\\n        this._getLines(start, count, function (lines, linesBuffer) {\\\\r\\\\n            if (useTransferrable) {\\\\r\\\\n                respondTransferrableMessage(new ResponseMessage(lines), linesBuffer);\\\\r\\\\n            }\\\\r\\\\n            else {\\\\r\\\\n                respondMessage(new ResponseMessage(lines));\\\\r\\\\n            }\\\\r\\\\n        });\\\\r\\\\n    };\\\\r\\\\n    TxtReaderWorker.prototype.sortAndMergeLineMap = function (lineMap) {\\\\r\\\\n        lineMap.sort(function (a, b) {\\\\r\\\\n            // sort lines in ascending order\\\\r\\\\n            if (typeof a === \\\'number\\\' && typeof b === \\\'number\\\') {\\\\r\\\\n                return a > b ? 1 : -1;\\\\r\\\\n            }\\\\r\\\\n            else if (typeof a === \\\'number\\\' && typeof b === \\\'object\\\') {\\\\r\\\\n                return a > b.start ? 1 : -1;\\\\r\\\\n            }\\\\r\\\\n            else if (typeof a === \\\'object\\\' && typeof b === \\\'number\\\') {\\\\r\\\\n                return a.start > b ? 1 : -1;\\\\r\\\\n            }\\\\r\\\\n            else if (typeof a === \\\'object\\\' && typeof b === \\\'object\\\') {\\\\r\\\\n                return a.start > b.start ? 1 : -1;\\\\r\\\\n            }\\\\r\\\\n            return 0;\\\\r\\\\n        });\\\\r\\\\n        for (var i = 1; i < lineMap.length; i++) {\\\\r\\\\n            // compare lines[i] with lines[i-1]\\\\r\\\\n            var prev = lineMap[i - 1];\\\\r\\\\n            var current = lineMap[i];\\\\r\\\\n            if (typeof current === \\\'number\\\' && typeof prev === \\\'number\\\') {\\\\r\\\\n                if (current === prev) {\\\\r\\\\n                    // duplicate line number, remove current one\\\\r\\\\n                    lineMap.splice(i, 1);\\\\r\\\\n                    i--;\\\\r\\\\n                }\\\\r\\\\n                else if (current === prev + 1) {\\\\r\\\\n                    lineMap[i - 1] = {\\\\r\\\\n                        start: prev,\\\\r\\\\n                        end: current\\\\r\\\\n                    };\\\\r\\\\n                    lineMap.splice(i, 1);\\\\r\\\\n                    i--;\\\\r\\\\n                }\\\\r\\\\n            }\\\\r\\\\n            else if (typeof current === \\\'number\\\' && typeof prev === \\\'object\\\') {\\\\r\\\\n                var prevEnd = getLinesRangeEnd(prev);\\\\r\\\\n                if (isLineWithinLinesRange(current, prev)) {\\\\r\\\\n                    lineMap.splice(i, 1);\\\\r\\\\n                    i--;\\\\r\\\\n                }\\\\r\\\\n                else if (current === prevEnd + 1) {\\\\r\\\\n                    if (prev.count !== undefined) {\\\\r\\\\n                        prev.count++;\\\\r\\\\n                    }\\\\r\\\\n                    else {\\\\r\\\\n                        prev.end = current;\\\\r\\\\n                    }\\\\r\\\\n                    lineMap.splice(i, 1);\\\\r\\\\n                    i--;\\\\r\\\\n                }\\\\r\\\\n            }\\\\r\\\\n            else if (typeof current === \\\'object\\\' && typeof prev === \\\'number\\\') {\\\\r\\\\n                if (isLineWithinLinesRange(prev, current)) {\\\\r\\\\n                    lineMap.splice(i - 1, 1);\\\\r\\\\n                    i--;\\\\r\\\\n                }\\\\r\\\\n            }\\\\r\\\\n            else if (typeof current === \\\'object\\\' && typeof prev === \\\'object\\\') {\\\\r\\\\n                var currentEnd = getLinesRangeEnd(current);\\\\r\\\\n                var prevEnd = getLinesRangeEnd(prev);\\\\r\\\\n                if (prevEnd >= current.start && prevEnd <= currentEnd) {\\\\r\\\\n                    // overlap, remove the prev one\\\\r\\\\n                    current.start = prev.start;\\\\r\\\\n                    if (current.count !== undefined) {\\\\r\\\\n                        current.count = currentEnd - current.start + 1;\\\\r\\\\n                    }\\\\r\\\\n                    lineMap.splice(i - 1, 1);\\\\r\\\\n                    i--;\\\\r\\\\n                }\\\\r\\\\n                else if (current.start >= prev.start && currentEnd <= prevEnd) {\\\\r\\\\n                    // current within prev range, delete current\\\\r\\\\n                    lineMap.splice(i, 1);\\\\r\\\\n                    i--;\\\\r\\\\n                }\\\\r\\\\n                else if (current.start === prevEnd + 1) {\\\\r\\\\n                    if (prev.count !== undefined) {\\\\r\\\\n                        prev.count += currentEnd - current.start + 1;\\\\r\\\\n                    }\\\\r\\\\n                    else {\\\\r\\\\n                        prev.end = currentEnd;\\\\r\\\\n                    }\\\\r\\\\n                    lineMap.splice(i, 1);\\\\r\\\\n                    i--;\\\\r\\\\n                }\\\\r\\\\n            }\\\\r\\\\n        }\\\\r\\\\n        return lineMap;\\\\r\\\\n    };\\\\r\\\\n    return TxtReaderWorker;\\\\r\\\\n}());\\\\r\\\\n\\\\n\\\\n//# sourceURL=webpack:///./txt-reader-worker.ts?\\\");\\n\\n/***/ })\\n\\n/******/ });\"])));\r\n        this.worker.addEventListener(\'message\', function (event) {\r\n            if (_this.verboseLogging) {\r\n                console.log(\'Main thread received a message from worker thread: \\r\\n\', event.data);\r\n            }\r\n            if (_this.runningTask === null) {\r\n                return;\r\n            }\r\n            var response = event.data;\r\n            if (response.taskId !== _this.runningTask.id) {\r\n                throw (\"Received task ID (\" + response.taskId + \") does not match the running task ID (\" + _this.runningTask.id + \").\");\r\n            }\r\n            if (response.done) {\r\n                // the task completes\r\n                _this.completeTask(response);\r\n            }\r\n            else {\r\n                // the task is incomplete, means it is a progress message\r\n                if (Object.prototype.toString.call(response.result).toLowerCase() === \'[object number]\' && response.result >= 0 && response.result <= 100) {\r\n                    _this.runningTask.updateProgress(response.result);\r\n                }\r\n                else {\r\n                    throw (\'Unkown message type\');\r\n                }\r\n            }\r\n        }, false);\r\n    }\r\n    TxtReader.prototype.sniffLines = function (file, lineNumber, decode) {\r\n        if (decode === void 0) { decode = true; }\r\n        return this.newTask(\'sniffLines\', {\r\n            file: file,\r\n            lineNumber: lineNumber,\r\n            decode: decode\r\n        });\r\n    };\r\n    TxtReader.prototype.loadFile = function (file, config) {\r\n        var _this = this;\r\n        this.file = file;\r\n        Object.defineProperty(this, \'lineCount\', {\r\n            value: 0,\r\n            writable: false\r\n        });\r\n        var data = {\r\n            file: file\r\n        };\r\n        if (config) {\r\n            data.config = this.getItertorConfigMessage(lodash_clonedeep_1[\"default\"](config));\r\n        }\r\n        return this.newTask(\'loadFile\', data).then(function (response) {\r\n            Object.defineProperty(_this, \'lineCount\', {\r\n                value: response.result.lineCount,\r\n                writable: false\r\n            });\r\n        });\r\n    };\r\n    TxtReader.prototype.setChunkSize = function (chunkSize) {\r\n        return this.newTask(\'setChunkSize\', chunkSize);\r\n    };\r\n    TxtReader.prototype.enableVerbose = function () {\r\n        this.verboseLogging = true;\r\n        return this.newTask(\'enableVerbose\');\r\n    };\r\n    TxtReader.prototype.getLines = function (start, count, decode) {\r\n        var _this = this;\r\n        if (decode === void 0) { decode = true; }\r\n        return this.newTask(\'getLines\', { start: start, count: count }).then(function (response) {\r\n            for (var i = 0; i < response.result.length; i++) {\r\n                if (decode) {\r\n                    response.result[i] = _this.utf8decoder.decode(response.result[i]);\r\n                }\r\n            }\r\n        });\r\n    };\r\n    TxtReader.prototype.getSporadicLines = function (sporadicLinesMap, decode) {\r\n        if (decode === void 0) { decode = true; }\r\n        return this.newTask(\'getSporadicLines\', {\r\n            sporadicLinesMap: sporadicLinesMap,\r\n            decode: decode\r\n        });\r\n    };\r\n    TxtReader.prototype.iterateLines = function (config, start, count) {\r\n        return this.newTask(\'iterateLines\', {\r\n            config: this.getItertorConfigMessage(lodash_clonedeep_1[\"default\"](config)),\r\n            start: start || null,\r\n            count: count || null\r\n        });\r\n    };\r\n    TxtReader.prototype.iterateSporadicLines = function (config, sporadicLinesMap) {\r\n        return this.newTask(\'iterateSporadicLines\', {\r\n            config: this.getItertorConfigMessage(lodash_clonedeep_1[\"default\"](config)),\r\n            lines: sporadicLinesMap\r\n        });\r\n    };\r\n    TxtReader.prototype.getItertorConfigMessage = function (config) {\r\n        var functionMap = [];\r\n        function functionToString(obj, entry) {\r\n            var path = entry;\r\n            if (typeof obj === \'object\') {\r\n                for (var i in obj) {\r\n                    var pathi = path + \"[\\\"\" + i + \"\\\"]\";\r\n                    if (typeof obj[i] === \'function\') {\r\n                        obj[i] = obj[i].toString();\r\n                        functionMap.push(pathi);\r\n                    }\r\n                    else if (typeof obj[i] === \'object\') {\r\n                        obj[i] = functionToString(obj[i], pathi);\r\n                    }\r\n                }\r\n            }\r\n            return obj;\r\n        }\r\n        return {\r\n            eachLine: config.eachLine.toString(),\r\n            scope: functionToString(config.scope, \"\") || {},\r\n            functionMap: functionMap\r\n        };\r\n    };\r\n    TxtReader.prototype.newTask = function (action, data) {\r\n        var reqMsg = new RequestMessage(action, data);\r\n        var task = new TxtReaderTask(this.newTaskId(), reqMsg, this);\r\n        this.taskList.push(task);\r\n        if (!this.runningTask) {\r\n            this.runTask(task);\r\n        }\r\n        else {\r\n            this.queuedTaskList.push(task);\r\n            task.state = TxtReaderTaskState.Queued;\r\n        }\r\n        return task;\r\n    };\r\n    TxtReader.prototype.completeTask = function (response) {\r\n        if (this.runningTask) {\r\n            this.runningTask.complete(response);\r\n            this.runningTask = null;\r\n            this.runNextTask();\r\n        }\r\n    };\r\n    TxtReader.prototype.runNextTask = function () {\r\n        if (this.queuedTaskList.length) {\r\n            this.runTask(this.queuedTaskList.shift());\r\n        }\r\n    };\r\n    TxtReader.prototype.runTask = function (task) {\r\n        this.runningTask = task;\r\n        this.worker.postMessage(task.requestMessage);\r\n        task.run();\r\n    };\r\n    TxtReader.prototype.newTaskId = function () {\r\n        var taskListLength = this.taskList.length;\r\n        if (taskListLength === 0) {\r\n            return 1;\r\n        }\r\n        else {\r\n            return this.taskList[taskListLength - 1].id + 1;\r\n        }\r\n    };\r\n    return TxtReader;\r\n}());\r\nexports.TxtReader = TxtReader;\r\n\n\n//# sourceURL=webpack:///./txt-reader.ts?");

/***/ })

/******/ });